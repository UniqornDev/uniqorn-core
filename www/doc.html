<!doctype html>
<html lang="en">
<head>
	<link rel="stylesheet" href="css/main3.css" />
	<meta charset="UTF-8">
	<title>Uniqorn - Documentation</title>
	<meta name="language" content="en">
	<link rel="stylesheet" href="css/prism.css" />
	<script type="text/javascript" src="js/prism.js"></script>
	<script type="text/javascript" src="js/doc.js"></script>
<script>
	if( location.hostname == "uniqorn.dev" ) {
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:5315836,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
	}
</script>
</head>
<body>
	<header>
		<a href="/"><img src="assets/unicorn.png" alt="Uniqorn" /></a>
		<p><a href="/">Uniqorn</a></p>
		<p>Serverless Java REST API</p>
	</header>
	<nav>
		<a class="l1" href="#overview">Overview</a>
		<a class="l2" href="#overview-showcase">Showcase</a>
		<a class="l2" href="#overview-features">Features</a>
		<a class="l1" href="#start">Getting Started</a>
		<a class="l2" href="#start-concepts">Basic Concepts</a>
		<a class="l2" href="#start-code">Code Structure</a>
		<a class="l1" href="#debug">Troubleshooting</a>
		<a class="l2" href="#debug-log">Logging</a>
		<a class="l2" href="#debug-debug">Debugging</a>
		<a class="l2" href="#debug-metrics">Metrics</a>
		<a class="l1" href="#howto">How-To's</a>
		<a class="l2" href="#howto-error">Error Handling</a>
		<a class="l2" href="#howto-parameter">Parameter Validation</a>
		<a class="l2" href="#howto-upload">File Upload</a>
		<a class="l2" href="#howto-download">File Download</a>
		<a class="l2" href="#howto-http">Http Fetch</a>
		<a class="l2" href="#howto-storage">Storage</a>
		<a class="l2" href="#howto-database">Database Query</a>
		<a class="l2" href="#howto-sharing">States &amp; Sharing Data</a>
		<a class="l2" href="#howto-chain">Chain Endpoints</a>
		<a class="l2" href="#howto-atomic">Atomic Operations</a>
		<a class="l2" href="#howto-background">Background Operations</a>
	</nav>
	<main>
		<section>
			<h1 id="overview">Overview</h1>
			<p>Uniqorn is a lightweight serverless Java runtime for deploying REST APIs with minimal overhead.</p>
			<p>
				It allows developers to focus on business logic by handling technical concerns such as compilation, deployment, and infrastructure management.
				Storage, security, and other services are configured globally and can be used within custom APIs, eliminating the need to implement them manually.
			</p>
			<p>Uniqorn runs on the Aeonics framework, ensuring minimal dependencies and efficient processing while maintaining a predictable execution model.</p>
			
			<p class="warning">Uniqorn is under development and some breaking changes may happen on minor releases. However, we are dedicated to providing the
			best seamless experience for your APIs.</p>
			
			<article>
			<h2 id="overview-showcase">Showcase</h2>
			<p>The Uniqorn framework is straightforward and provides a minimal set of classes to handle common operations.
				It avoids annotations, preprocessors, and reflection to ensure that the code executed is the one you wrote.</p>
			<pre><code class="language-java">import uniqorn.*;

public class Custom implements Supplier&lt;Api&gt; {
	public Api get() {
		return new Api("/api/test", "GET")
			.parameter("name")
			.process(data -&gt; {
				return JSON.object()
					.put("hello", data.get("name"));
			});
	}
}</code></pre>
			<p class="tip">See the <a href="#start-code">Code Structure</a> section for more details.</p>
			</article>
			
			<article>
			<h2 id="overview-features">Features</h2>
			<p>Uniqorn is both a platform and a framework, giving you control over API development without the usual hassle. 
				Some features are built into the runtime and configurable via the web interface, no coding required. 
				Others are exposed through the framework, providing utilities to streamline development while keeping things predictable.</p>
			
			<h3>Platform</h3>
			<ul>
				<li><strong>Runtime Management</strong>: Handles execution, memory allocation, and scheduling to keep APIs running efficiently without manual tuning.</li>
				<li><strong>Networking &amp; Routing</strong>: Manages HTTP handling, connectivity, and API endpoint routing, so you don't have to wire things up manually.</li>
				<li><strong>Security Policies</strong>: Centralized setup for authentication, encryption, and access control, ensuring consistency across all APIs.</li>
				<li><strong>Storage Abstraction</strong>: Define and manage storage independently from your code, keeping APIs clean and decoupled.</li>
				<li><strong>Traffic Smoothing</strong>: Built-in queuing absorbs traffic spikes and optimizes workload distribution without extra infrastructure.</li>
				<li><strong>Logging &amp; Monitoring</strong>: Shared observability framework providing insights into API performance, errors, and system behavior.</li>
			</ul>
			<h3>Framework</h3>
			<ul>
				<li><strong>Data Oriented</strong>: Data is accessible using a JSON-like structure with plenty of built-in coercions, so you don't waste time on boilerplate parsing or POJO mapping.</li>
				<li><strong>Built-in Parameter Validation</strong>: Automatically enforces input constraints, sanitizing API parameters to prevent bad data and security risks.</li>
				<li><strong>Intuitive Utility Wrappers</strong>: Simplifies interactions with platform features like storage, security, and logging so you can focus on logic, not plumbing.</li>
				<li><strong>Effortless HTTP Calls</strong>: Provides a clean, no-fuss way to fetch external data and define webhooks.</li>
				<li><strong>Optional Inline API Docs</strong>: Generate API documentation directly from code, keeping it always up-to-date with minimal effort.</li>
				<li><strong>Event-Driven Execution</strong>: Supports asynchronous patterns out of the box, making it easy to handle background tasks and real-time events.</li>
				<li><strong>Controlled Concurrency</strong>: Simple mechanisms to define parallelism limits, preventing resource starvation and ensuring predictable performance.</li>
				<li><strong>Fluent API Design</strong>: Reduces redundancy with a chainable, expressive syntax for cleaner, more readable code.</li>
			</ul>
			</article>
		</section>
		
		<section>
			<h1 id="start">Getting Started</h1>
			<p>This section walks you through setting up your first API.</p>
			<p>The approach might differ from what you're used to, but don't worry, you'll get the hang of it quickly.</p>
			
			<article>
			<h2 id="start-concepts">Basic Concepts</h2>
			<p>Uniqorn provides a structured way to develop and deploy APIs while keeping things lightweight and flexible. 
			Let's introduce the fundamental principles of how your environment is organized and how APIs are managed.</p>
			
			<h3>Instance &amp; Authentication</h3>
			<p>When you subscribe to a plan, Uniqorn automatically provisions a dedicated instance for you. The details to 
			access this instance are sent via email, including the connection credentials. Depending on 
			your plan, your instance may run on a <em>shared</em> infrastructure (for trial and personal plans) or on fully 
			<em>dedicated</em> infrastructure (for team and enterprise plans).</p>
			<p class="tip">We will never-ever ask for your credentials in any way, your privacy matters.<br />If you do not receive our emails,
			please check your spam filter.<br />Be sure to always check the sender of the email to detect fraudulent phishing attempts.</p>
			<p>For security reasons, logging in requires Multi-Factor Authentication (MFA). You will need to configure an authenticator app 
			such as Google Authenticator, Authy, or any compatible alternative at your first connection. This extra layer of security ensures that access to 
			your environment is protected.</p>
			
			<h3>Workspaces &amp; Organization</h3>
			<p>Once inside your personal instance, you can organize your work using <em>workspaces</em>. A workspace is a logical grouping of resources 
			that allows you to structure your APIs and services in a way that makes sense for your use case. 
			Workspaces can represent different projects, API versions, staging environments, or any other logical separation you need. 
			However, workspaces do not impose physical isolation. All APIs and resources within your instance <em>share the same execution environment</em>, 
			meaning they can interact with each other and have the possibility to produce side effects, for better or worst.</p>
			<p class="tip">If complete separation is required, such as between development and production environments, it is recommended to use 
			separate instances (another subscription) rather than relying solely on workspaces.</p>
			
			<h3>Configuring Resources &amp; Deploying APIs</h3>
			<p>Within each workspace, you can configure various static resources and deploy API endpoints. Static resources include database connections, 
			storage locations, and other necessary components that support your APIs. These configurations remain available globally within your instance, 
			ensuring that APIs across different workspaces can access them as needed.</p>
			<p>Deploying an API is a straightforward process. You have the option to:
			<ul>
				<li>import an existing code file,</li>
				<li>define an API using an OpenAPI specification,</li>
				<li>or write the code manually in the editor.</li>
			</ul>
			Regardless of the method used, each deployment requires a review step before the API is published and made available. 
			APIs can also be enabled or disabled on demand without deleting them, allowing for quick modifications and testing 
			without affecting the overall setup.</p>
			
			<h3>Live Code Execution</h3>
			<p>When you publish an API, the raw code is <em>dynamically compiled and deployed</em> instantly, requiring no additional build steps or restarts. 
			This ensures that changes take effect immediately without downtime. If an error occurs or an update needs to be made, you can simply modify 
			the endpoint and republish it. There is no built-in rollback mechanism per-se, but if a previous version needs to be restored, you can 
			reload a manually tagged version of the code.</p>
			<p class="warning">It may happen that your instance is stuck because of infitinite loops or other mistakes. You have the possibility to trigger
			a full instance restart to reset the system and perform the required changes.<br />
			If you encounter unrecoverable issues, please contact us.</p>
			
			<h3>Versioning APIs</h3>
			<p>Uniqorn provides a simple tagging mechanism for versioning APIs. At any point, you can manually tag a version of your API to save its current 
			state. This allows you to return to that version later if needed. However, this is not a replacement for traditional version control tools 
			like Git, as it does not track diffs or maintain a full history of modifications. Instead, it serves as a lightweight way to bookmark significant 
			versions of your API for future reference.</p>
			
			<h3>Key Considerations</h3>
			<p>Since all APIs within an instance share the same execution environment, it is important to consider potential interactions and side effects. 
			Workspaces provide an organizational structure, but they do not enforce runtime isolation. If strict separation is required, using separate instances 
			for different environments is the recommended approach.</p>
			<p>For managing API updates, the ability to quickly republish an endpoint simplifies error recovery, but there is no automated rollback. Users are 
			encouraged to tag stable versions to facilitate manual rollbacks if necessary. While Uniqorn streamlines deployment and management, it does not 
			replace traditional development workflows, so integrating with external version control systems remains a best practice for tracking changes 
			comprehensively. The entire Uniqorn system is also API-based so it is fairly straightforward to setup a CI/CD system to automate the deployment process.</p>
			</article>
			
			<article>
			<h2 id="start-code">Code Structure</h2>
			<p>Let's see how Uniqorn APIs are structured and the different components involved in defining an endpoint. While this does not replace full 
			Javadoc documentation, it provides enough detail to help you understand the overall design and quickly get started.</p>
			
			<pre><code class="language-java">import uniqorn.*;

public class Custom implements Supplier&lt;Api&gt; {
	private AtomicInteger counter = new AtomicInteger(0);
	public Api get() {
		return new Api("/api/hello", "GET")
			.parameter("name")
			.description("This API will greet the user and return a counter value")
			.allowUser("Bob")
			.concurrency(2)
			.process(data -&gt; {
				return JSON.object()
					.put("hello", data.get("name"))
					.put("counter", counter.incrementAndGet());
			});
	}
}</code></pre>
			<p>In the following sections we will dissect each part of the code to know more about how it works and implications.</p>
			
			<h3>Imports and Common Dependencies <span class="light">(mandatory)</span></h3>
			<p>Every API implementation starts with the <code>uniqorn.*</code> import, notice that there is no package defined, on purpose.</p>
			<pre><code class="language-java">import uniqorn.*;</code></pre>
			<p>When you use this import, Uniqorn automatically includes commonly used Java packages and framework utilities.
			This reduces boilerplate, so you don't have to manually import standard libraries like <code>java.util.*</code> unless you need something 
			beyond the default set.</p>
			
			<h3>Defining an API Supplier <span class="light">(mandatory)</span></h3>
			<p>Uniqorn follows a supplier-based approach for defining APIs. Instead of enforcing strict class naming conventions, you implement a 
			<code>Supplier&lt;Api&gt;</code> to return the actual API instance:</p>
			<pre><code class="language-java">public class Custom implements Supplier&lt;Api&gt; {
	public Api get() {</code></pre>
			<p>Unlike traditional Java frameworks, the class name is irrelevant, different APIs can use the same or different class names without conflict.
			This structure allows you to define protected member variables, helper methods, or inner classes inside the API definition. These internal 
			elements remain isolated to the specific API and are not shared with other APIs.</p>
			<pre><code class="language-java">public class Custom implements Supplier&lt;Api&gt; {
	private AtomicInteger counter = new AtomicInteger(0);
	public Api get() {</code></pre>
			<p class="tip">If you need to share data or functionality between multiple APIs, refer to the <a href="#howto-sharing">States &amp; Sharing Data</a> section of the documentation.</p>
			
			<h3>The API Endpoint <span class="light">(mandatory)</span></h3>
			<p>The API instance is created with a path and HTTP method:</p>
			<pre><code class="language-java">		return new Api("/api/test", "GET")</code></pre>
			<p>You have complete control over the path structure and HTTP method. Paths can include <em>named parameters</em> in curly brackets, such as 
			<code>{name}</code>, which will automatically be mapped to incoming request parameters.</p>
			<p>You can use any HTTP method you like, although it must match exactly what the request contains in a case-sensitive fashion.</p>
			
			<h3>Declaring Parameters <span class="light">(optional)</span></h3>
			<p>Uniqorn supports fluent API design, allowing for cleaner and more readable code. 
			However, you are free to structure the code differently if you prefer.</p>
			<p>To define input parameters, use:</p>
			<pre><code class="language-java">			.parameter("name", (value) -&gt; value.size() > 0)</code></pre>
			<p>The framework automatically resolves parameters based on the incoming request type. Whether the request is <code>GET</code>, 
			<code>POST</code>, <code>queryString</code>, <code>multipart</code>, <code>urlencoded</code>, or <code>json</code>, 
			Uniqorn extracts the correct values seamlessly. Parameters are identified <em>by name</em> and can 
			optionally include a validation function to enforce constraints.</p>
			
			<h3>Adding Inline Documentation <span class="light">(optional)</span></h3>
			<p>For better organization and clarity, you can embed documentation directly into the API definition:</p>
			<pre><code class="language-java">			.summary("My first API")
			.description("This API will greet the user if the name is provided")
			.returns("A JSON object with the 'hello' property set with the provided name")</code></pre>
			<p>These descriptions help maintain clear, structured code without relying on external documentation tools.
			The API documentation can be shared with your consumers and always reflect the latest deployed version.</p>
			
			<h3>Managing Security <span class="light">(optional)</span></h3>
			<p>Uniqorn provides built-in access control mechanisms, allowing you to <em>allow</em> or <em>deny</em> specific users, groups, or roles 
			at the API level. Access control elements (users, roles, groups) are managed centrally within your Uniqorn instance, ensuring consistency across all endpoints.</p>
			<pre><code class="language-java">			.allowRole("manager") .denyRole("customer")
			.allowGroup("admins") .denyGroup("users")
			.allowUser("Bob")     .denyUser("Alice")</code></pre>
			<p>You can specify multiple roles, groups or users at once and use any combination of the above methods. The precedence rules are:</p>
			<ol>
				<li>By default the API is <em>public</em> and everyone can access it.</li>
				<li><em>Users</em> are processed first and are either allowed or denied if a corresponding rule is set.</li>
				<li><em>Roles</em> are processed second and match all the user roles to allow or deny access.</li>
				<li><em>Groups</em> are processed third with all the user groups with the same logic.</li>
				<li>If nothing matched earlier and at lease one <code>allow*</code> clause was specified, then access is denied 
					because it means we could not explicitly allow the user. If there was no other explicit allow rules, then access is granted.</li>
			</ol>
			
			<h3>Controlling Concurrency <span class="light">(optional)</span></h3>
			<p>Uniqorn allows you to limit how many requests can be processed in parallel for a specific API. 
			This ensures controlled execution and prevents excessive resource usage.</p>
			<pre><code class="language-java">			.concurrency(4)</code></pre>
			<p>By default, there is no concurrency limit, APIs can handle unlimited parallel requests as permitted by system resources. 
			Setting a hard limit on concurrency can be useful in cases where you need to prevent race conditions by ensuring an API is 
			accessed by only one or a few users at a time. If the API performs resource-intensive operations and should not be overloaded,
			or if you want to throttle access to prevent excessive use, you can also define the concurrency limit.</p>
			<p class="tip">For a strict single-user access, set <code>.concurrency(1)</code>.
			<br />For unmetered access, do not specify the concurrency limit, or set <code>.concurrency(-1)</code></p>
			
			<h3>Defining API Logic <span class="light">(mandatory)</span></h3>
			<p>The core of the API is the <em>process</em> function, which defines the actual logic executed when the endpoint is called. 
			This function receives the incoming request parameters as a JSON object and should return a JSON object as a response.</p>
			<pre><code class="language-java">			.process(data -&gt; {
				return JSON.object()
					.put("hello", data.get("name"));
			});</code></pre>
			<p>The <code>data</code> parameter contains all resolved input parameters, regardless of whether they come from query parameters, 
			request bodies, or other sources. Uniqorn automatically handles data extraction and validation.</p>
			<p class="tip">You can have access to the current authenticated user using <code>.process((data, user) -&gt; {})</code> if needed.</p>
			</article>
		</section>
		
		<section>
			<h1 id="debug">Troubleshooting</h1>
			<p>When working with live APIs running on a server, traditional debugging tools like an IDE's debugger are not an option. 
			Instead, you need real-time insights into your API's execution flow, errors, and performance. The system provides a built-in 
			management interface that allows you to log messages, inspect runtime variables, analyze call stacks, and monitor performance 
			metrics, all without disrupting the running application.</p>
			<p>This section covers the three primary ways to troubleshoot your API: <em>Logging</em>, <em>Debugging</em>, and <em>Metrics</em>. 
			Each of these tools serves a distinct purpose, helping you diagnose issues efficiently in a live environment.</p>
			
			<article>
			<h2 id="debug-log">Logging</h2>
			<p>Logging is the simplest and most effective way to track what your API is doing. By writing logs, you create a live record of 
			execution flow, errors, and important state changes. These logs can be visualized directly from the management interface, allowing 
			you to monitor <em>real-time behavior</em> without modifying the API's response. Proper logging helps you understand what happened before 
			an error occurred and provides essential context for troubleshooting unexpected behavior.</p>
			<p class="tip">Logs are streamed live through a WebSocket connection. You can visualize it in the management interface or consume it from any 
			compatible log management system.</p>
			<h3>Logging API</h3>
			<p>The <code>Api</code> class exposes 2 methods to record logs:</p>
			<pre><code class="language-java">Api.log(int level, String message, Object...data);
Api.log(int level, Exception error);</code></pre>
			<p>Uniqorn logging uses a level-based system where the severity of a log entry ranges between <em>0 (detailed logs)</em> and <em>1000 (critical issues)</em>.
			Messages below the configured log level are ignored, ensuring that only relevant logs appear when debugging production environments.</p>
			<p>Reference values for the log level are:</p>
			<ul>
				<li><em>1000 (severe)</em>: Indicates a serious failure that requires immediate attention. This level is used for unrecoverable errors, such as system 
				crashes, database corruption, or data loss. Developers can use this level for business-critical failures, like failed financial transactions or security breaches.</li>
				<li><em>900 (warning)</em>: Represents errors that do not halt execution but may lead to problems. This includes degraded performance, deprecated API usage, 
				or excessive resource consumption. Business logic may use this for cases like failed authentication attempts or temporary service disruptions.</li>
				<li><em>800 (info)</em>: Logs normal system behavior, such as API start-up, shutdown, or important state changes. This level is useful for business events, 
				such as successful user logins, purchases, or account updates.</li>
				<li><em>700 (config)</em>: Logs configuration-related events, such as loaded settings, environment variables, or changes in runtime behavior. 
				Useful for tracking how the system is initialized and whether any dynamic configuration updates occur.</li>
				<li><em>500 (fine)</em>: A more detailed debugging level that provides insights into the general execution path of the application. Useful for tracking 
				function calls, loop iterations, or performance markers.</li>
				<li><em>400 (finer)</em>: Logs finer details of execution, such as parameter values, cache hits/misses, or database query execution times. Useful 
				for troubleshooting performance bottlenecks.</li>
				<li><em>300 (finest)</em>: Logs the most granular details, usually for deep troubleshooting. This level is used to trace function arguments, 
				individual computations, or low-level operations.</li>
			</ul>
			<p>Logging levels are not restricted to the predefined reference values, you can use any intermediate level to fine-tune log granularity according to your needs. 
			For instance, setting a custom level like 450 allows you to log messages that fall between "finer" and "fine" without affecting lower or higher severity logs.</p>
			<p>However, it is important to consider that every log operation incurs a small processing overhead, even if the message is ultimately filtered out by the log 
			level settings. While this impact is negligible for occasional logs, <em>excessive logging can slow down API performance</em>. To maintain efficiency, it is recommended 
			to remove verbose logging or troubleshooting logs unless they are strictly necessary.</p>
			<p class="tip">If a log message contains <code>{}</code> placeholders, they will be dynamically replaced by the provided data arguments.
			If more data is provided than placeholders, the extra values are ignored.</p>
			<pre><code class="language-java">Api.log(800, "System activated"); // Simple log message
Api.log(500, "User {} has logged in", userId); // Log message with parameter injection

try { ... }
catch(Exception error) {
	Api.log(900, error); // Log error details with the stack trace
}</code></pre>
			<p class="example">{"date": 1741425960834, "level": 800, "type": "uniqorn.Api", "message": "System activated"}
			
{"date": 1741425960849, "level": 500, "type": "uniqorn.Api", "message": "User 41ae9da2-a875558911263000 has logged in"}

{"date": 1741426369953, "level": 900, "type": "uniqorn.Api", "message": "java.lang.Exception: Invalid data
	at _m_1907317704888500_//_m_1907317704888500_.Custom.lambda$get$0(Custom.java:8)
	at Loader-uniqorn/uniqorn/uniqorn.Api.lambda$process$1(Api.java:136)
	at Loader-uniqorn/uniqorn/local.Endpoints.lambda$static$0(Endpoints.java:121)"}</p>
			</article>
			
			<article>
			<h2 id="debug-debug">Debugging</h2>
			<p>Since attaching an interactive debugger is not possible in a serverless context, debugging in Uniqorn relies on live variable inspection and call stack tracing. 
			The management interface allows you to visualize of your API's state at specific execution points, displaying variable values 
			and execution history. This method provides a practical alternative to stepping through execution as you would in a local debugger.</p>
			<p>When an error occurs or unexpected behavior is encountered, logging alone may not be sufficient. Debugging allows you to capture variable states 
			and the call stack at any execution point, offering deeper insights into your API’s behavior without modifying log levels.</p>
			<h3>Debug API</h3>
			<p>The <code>Api</code> class offers one method to expose debug information:</p>
			<pre><code class="language-java">Api.debug(String key, Object...data);</code></pre>
			<p>Each debug entry is assigned a <em>tag</em>, which allows filtering and categorization in the management interface. As the number of debug points grows, 
			identifying which output corresponds to which line can become tedious, hence, tagging each log entry helps quickly locate relevant 
			sections of your code.</p>
			<p>Debugging automatically captures:</p>
			<ul>
				<li>The <em>stack trace</em> at the time of execution, with some non-essential entries automatically removed to focus on relevant parts.</li>
				<li>Provided <em>variables</em>, converted to a human-readable JSON format for easier inspection.</li>
			</ul>
			<p class="tip">Debug information is streamed live through a WebSocket connection, making it accessible in the management interface 
			or from any compatible system.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		...
		Api.debug("Checkpoint A", userId, userName);
		...
	});</code></pre>
			<p class="example">{
	"stack": [
		"_m_1907317704888500_//_m_1907317704888500_.Custom.lambda$get$0(Custom.java:8)",
		"Loader-uniqorn/uniqorn/uniqorn.Api.lambda$process$1(Api.java:136)",
		"Loader-uniqorn/uniqorn/local.Endpoints.lambda$static$0(Endpoints.java:121)"
	],
	"values": [
		8755589,
		"John Doe"
	]
}</p>
			<p>This output allows you to trace execution flow and inspect the values of key variables in real time, making it a powerful 
			tool for diagnosing issues without disrupting the running API.</p>
			<p class="warning">Debugging is a costly operation, do not forget to comment or remove debug code when your API is ready.</p>
			</article>
			
			<article>
			<h2 id="debug-metrics">Metrics</h2>
			<p>Monitoring and performance troubleshooting requires more than just error logs, it demands an understanding of how the system is behaving over time. 
			Built-in metrics provide insights into API request rates, execution times, error frequencies, and resource consumption. These metrics help 
			identify performance bottlenecks, unexpected spikes in traffic, and potential scaling issues. By interpreting these real-time statistics, 
			you can optimize your API's performance and ensure it runs efficiently under varying loads.</p>
			
<p class="todo">Coming soon...</p>
			</article>
		</section>
			
		<section>
			<h1 id="howto">How-To's</h1>
			<p>This part of the documentation provides more examples and guidance with the most common operations.</p>
			
			<article>
			<h2 id="howto-error">Error Handling</h2>
			<p>When building an API, proper error handling is essential to ensure meaningful responses to clients.</p>
			<p>HTTP response codes indicate whether a request was successful or if an error occurred. Here's a quick recap of relevant status code ranges:</p>
			<ul>
				<li><em>2xx (Success)</em>: The request was successful (e.g., <code>200 OK</code>, <code>204 No Content</code>).</li>
				<li><em>3xx (Redirection)</em>: The client must take additional action (e.g., <code>301 Moved Permanently</code>).</li>
				<li><em>4xx (Client Errors)</em>: The request is incorrect or unauthorized (e.g., <code>400 Bad Request</code>, 
				<code>403 Forbidden</code>, <code>404 Not Found</code>).</li>
				<li><em>5xx (Server Errors)</em>: The server encountered an error while processing the request (e.g., <code>500 Internal Server Error</code>, 
				<code>503 Service Unavailable</code>).</li>
			</ul>
			<h3>Unhandled Errors</h3>
			<p class="tip">The API process function allows any exception to be thrown to reduce the boilerplate try/catch code.</p>
			<p>If your API method throws an exception and you do not handle it, the framework will automatically return a <code>500 Internal Server Error</code>, 
			which is vague and unhelpful. Moreover, it could potentially leak some sensitive information to the caller.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		int result = 10 / 0; // This will cause a division by zero exception
		return JSON.object().put("result", result);
	});</code></pre>
			<p>Response:</p>
			<p class="example">HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{
	"error": {
		"code": 500,
		"message": "/ by zero"
	}
}</p>
			<p>This is not ideal because (1) the client may not get useful information about what went wrong, and (2) it does not differentiate 
			between a developer mistake and an expected failure.</p>
			<h3>Controlled Errors</h3>
			<p>To emit controlled error responses, you should use <code>Api.error(int code, String message)</code> or 
			<code>Api.error(int code, Data data)</code>. These methods will throw a recognized exception, stopping further execution and ensuring 
			the correct HTTP status code is returned.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		if (data.isNull("name"))
			Api.error(400, "Missing name parameter");
		return null;
	});</code></pre>
			<p>Response:</p>
			<p class="example">HTTP/1.1 400 Bad Request
Content-Type: application/json

{
	"error": {
		"code": 400,
		"message": "Missing name parameter"
	}
}</p>
			<p>If you need more control over the returned data, you can use the other variant and supply your own response.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		if (data.isNull("name"))
			Api.error(400, JSON.object()
				.put("parameter", "name")
				.put("cause", "Cannot be null"));
		return null;
	});</code></pre>
			<p>Response:</p>
			<p class="example">HTTP/1.1 400 Bad Request
Content-Type: application/json

{
	"parameter": "name",
	"cause": "Cannot be null"
}</p>
			<h3>Graceful Handling</h3>
			<p>The API process function has a failsafe mechanism to return a 500 error in case an exception happens. Although, it is always best to 
			surround sensitive operations in a <code>try/catch</code> block. This will ensure your API fails gracefully rather than exposing 
			internal server errors and allows you to control what message the client receives.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		try {
			int result = Integer.parseInt(data.get("size")); // Might throw NumberFormatException
		} catch (NumberFormatException e) {
			Api.error(400, "Invalid number");
		}
		return null;
	});</code></pre>
			</article>
			
			<article>
			<h2 id="howto-parameter">Parameter Validation</h2>
			<p>Proper parameter validation ensures that your API only processes valid and expected inputs, preventing unnecessary errors and 
			improving security. The framework automatically collects and populates declared API parameters while ignoring any extra, unsolicited data.</p>
			<p class="warning">There is no parameter validation rule by default. If needed, you should supply the validation rule in your code.</p>
			<h3>How Parameter Validation Works</h3>
			<ul>
				<li>You declare required parameters using the <code>parameter(String name)</code> function.</li>
				<li>You can add a <em>validation predicate</em> as a second argument to enforce constraints.</li>
				<li>If a parameter fails validation, the API does not execute the processing function and instead 
				returns a <code>400 Bad Request</code> with a structured error message.</li>
			</ul>
			<p class="example">HTTP/1.1 400 Bad Request
Content-Type: application/json

{
	"error": {
		"code": 400,
		"message": "Parameter validation failed for '[parameter-name]'"
	}
}</p>
			<p class="tip">The <code>Input</code> class contains various built-in validation rules that you can apply to your parameters.</p>
			<h3>Basic Validation</h3>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.parameter("name", Input.isNotEmpty);</code></pre>
			<p>This parameter uses one of the built-in validation rules from the <code>Input</code> class. Check the Javadoc for more possibilities.</p>
			<h3>Combining Multiple Validations</h3>
			<p>You can chain multiple predefined validation helpers to enforce stricter rules.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.parameter("email", Input.isEmpty.or(Input.isEmail));</code></pre>
			<p>In this case, we allow an optional parameter, but if a value is provided, it must be an email address.</p>
			<h3>Custom Validation</h3>
			<p>You can provide a custom validation function if the built-in ones are not enough.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.parameter("age", age -> age.asNumber() > 18);</code></pre>
			<p>This validation method leverages the native JSON type coercion to a numeric value using <code>asNumber()</code> and checks if the value is above 18.</p>
			</article>
			
			<article>
			<h2 id="howto-upload">File Upload</h2>
			<p>Api consumers can upload files to your endpoint using classic <code>multipart/form-data</code> uploads. Files are treated like any other input parameter, 
			meaning you must declare them explicitly in the parameter list and validate them as file inputs.</p>
			<pre><code class="language-java">new Api("/api/test", "POST")
	.parameter("image", Input.isFile);</code></pre>
			<h3>File Data Structure</h3>
			<p>When a file is uploaded, it is represented in the data object as a JSON structure:</p>
			<p class="example">{
	"name": "example.jpg",
	"mime": "image/jpeg",
	"content": "ÿØÿà..JFIF..."
}</p>
			<ul>
				<li><em>name</em>: the original file name supplied by the user</li>
				<li><em>mime</em>: the file's MIME type as it was provided in the request</li>
				<li><em>content</em>: the binary content (stored as a string)</li>
			</ul>
			<p>Since the file's content is stored as a binary string, you must convert it into raw bytes for further processing:</p>
			<pre><code class="language-java">byte[] content = file.asString("content").getBytes(StandardCharsets.ISO_8859_1);</code></pre>
			<p class="warning">Using any other charset may alter the binary data and corrupt the uploaded file. 
			Always use <code>ISO-8859-1</code> to ensure the bytes remain intact.</p>
			<p class="tip">Files are loaded directly into memory as JSON structures and are not offloaded to disk.
			<br />This means that file uploads are limited by available RAM. Larger files will be rejected by the system automatically.</p>
			<h3>Processing File Uploads</h3>
			<p>In the API process function, you can process it like a JSON object. Do not forget to enforce parameter validation:</p>
			<pre><code class="language-java">new Api("/api/test", "POST")
	.parameter("image", Input.isFile
		.and(Input.hasFileExtension(".jpg"))
		.and(Input.hasMimeType("image/jpeg"))
		.and(Input.maxSize(512000)))
	.process(data -> {
		byte[] jpg = data.get("image").asString("content").getBytes(StandardCharsets.ISO_8859_1);
		...
	});</code></pre>
			</article>
			
			<article>
			<h2 id="howto-download">File Download</h2>
			<p>By default, Uniqorn APIs work with JSON data, a flexible and widely used format. However, there are cases where you need to return files instead 
			of JSON, such as XML documents, ZIP archives, PDFs, or images.</p>
			<p>To achieve this, Uniqorn uses a special JSON response format to use in your APIs that instructs the system to handle the response as a file:</p>
			<p class="example">{
	"isHttpResponse": true,
	"code": 200,
	"headers": {},
	"mime": "application/xml",
	"body": "&lt;tag&gt;>value&lt;/tag&gt;"
}</p>
			<ul>
				<li><em>isHttpResponse</em>: Marks the response as an HTTP response override.</li>
				<li><em>code</em>: Specifies the HTTP status code (optional).</li>
				<li><em>headers</em>: Allows custom response headers (optional).</li>
				<li><em>mime</em>: Defines the file's MIME type (equivalent to setting the <code>Content-Type</code> header).</li>
				<li><em>body</em>: Contains the actual file content.</li>
			</ul>
			<p class="tip">When sending binary files, you need to convert the content to a binary-safe string using <code>ISO-8859-1</code> 
			encoding. This prevents corruption when transmitting raw bytes.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		byte[] pdf = ...; // Your binary file content
		return JSON.object()
			.put("isHttpResponse", true)
			.put("mime", "application/pdf")
			.put("body", new String(pdf, StandardCharsets.ISO_8859_1));
	});</code></pre>
			</article>

			<article>
			<h2 id="howto-http">Http Fetch</h2>
			<p>Uniqorn provides a simple and efficient way to make HTTP requests using the Http class. You can use it to send or fetch 
			data from remote endpoints effortlessly.</p>
			<p>There are two main methods:</p>
			<ul>
				<li><em>get()</em>: Used for retrieving data without a request body.</li>
				<li><em>post()</em>: Used for sending data in the request body.</li>
			</ul>
			<p>Both methods support optional overloads for sending additional data parameters, specifying custom headers, choosing a specific HTTP method,
			and defining a timeout (in milliseconds).</p>
			<pre><code class="language-java">Http.get(String url);
Http.get(String url, Data queryString);
Http.get(String url, Data queryString, Data headers);
Http.get(String url, Data queryString, Data headers, String method);
Http.get(String url, Data queryString, Data headers, String method, int timeout);

Http.post(String url);
Http.post(String url, Data body);
Http.post(String url, Data body, Data headers);
Http.post(String url, Data body, Data headers, String method);
Http.post(String url, Data body, Data headers, String method, int timeout);</code></pre>
			<h3>Handling Responses and Errors</h3>
			<p>If the HTTP call succeeds, the response is returned as a JSON string object. If the response MIME type is <code>application/json</code>, 
			it is automatically parsed into a full JSON object.</p>
			<p>If the request fails with an HTTP status &ge;400, an <code>Http.Error</code> is thrown, containing both the status <em>code</em> and response 
			<em>body</em>.</p>
			<p>If the call fails due to connectivity issues or other causes, a runtime exception is thrown.<br />The most basic example is:</p>
			<pre><code class="language-java">Data response = Http.get("https://api.example.com/data");
System.out.println(response.asString());</code></pre>
			<p class="tip">The response headers are not available when using the <code>Http</code> class. We focus on the content itself.</p>
			<p>If the response is advertized as JSON format, it will be automatically parsed into a Data object. Otherwise it will be a simple string.<br />
			An example of a request with proper error handling is as follows:</p>
			<pre><code class="language-java">try {
	Data response = Http.post("https://api.example.com/data", 
		JSON.object().put("amount", 42), // the data to send
		JSON.object().put("Authorization", "Bearer my-token"), // additional headers
		"PUT", // http method
		5000 // timeout
	);
}
catch (Http.Error error) { ... }
catch (Exception other) { ... }
			</code></pre>
			<p>Note that the <code>Http</code> class is <em>synchronous</em> and will wait for completion. This is because the context of your API is 
			already asynchronous, so there is no added value to complicate things further. However, if you absolutely need an asynchronous behavior,
			you can trigger a <a href="#howto-background">Background Operation</a>.</p>
			<p>If you want to upload a file to the remote endpoint, you can use the same JSON file structure as for a <a href="#howto-upload">File Upload</a>
			and specify a <code>Content-Type: multipart/form-data</code> header.</p>
			<pre><code class="language-java">Data response = Http.post("https://api.example.com/data", 
	JSON.object().put("image", JSON.object()
		.put("name", "picture.jpg")
		.put("mime", "image/jpeg")
		.put("content", ...)),
	JSON.object().put("Content-Type", "multipart/form-data")
);</code></pre>
			</article>
			
			<article>
			<h2 id="howto-storage">Storage</h2>
<p class="todo">Coming soon...</p>
			</article>
			
			<article>
			<h2 id="howto-database">Database Query</h2>
<p class="todo">Coming soon...</p>
			</article>
			
			<article>
			<h2 id="howto-sharing">States &amp; Sharing Data</h2>
			<p>When building APIs, you may need to share data between successive calls to the same endpoint or across different endpoints. 
			While you can always use persistent <a href="#howto-storage">Storage</a> (database, file system, etc.), Uniqorn provides <em>in-memory state</em> sharing for 
			temporary data storage.</p>
			<h3>Local vs. Global State</h3>
			<p>Uniqorn offers two types of transient storage:</p>
			<ul>
				<li><em>Local state</em> via <code>State.local()</code>. Data stored here is only accessible within the same API.</li>
				<li><em>Global state</em> via <code>State.global()</code>. Shared across all APIs in the instance.</li>
			</ul>
			<p class="warning">These states are transient, they do not persist beyond the lifecycle of the instance.
			If you need to store data permanently, use a database or other storage.</p>
			<h3>Using Local and Global States</h3>
			<p>Local state is useful when an endpoint needs to store values that are specific to its execution but don't need to be shared with other APIs.
			Global state allows APIs to share data across endpoints.</p>
			<p>You can eventually scope the state for a specific user, and set an automatic expiration time.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process((data, user) -> {
		// set a local state for the user with an expiration time of 5s
		State.local("key", "value", user, 5000);
		
		// set a global state not bound to any user, and does not expire
		State.global("key", "value");
		
		return JSON.object()
			.put("local-per-user", State.local("key", user))
			.put("global", State.global("common"));
	});</code></pre>
			<p>You can store any object type in the state. When fetching the value, the result is <em>auto-casted</em> 
			to the receiving type. If it does not match, it will throw an exception.</p>
			<pre><code class="language-java">State.local("key", 42); // the value type is an integer
int value = State.local("key"); // auto-casting to int
String value2 = State.local("key"); // throws a ClassCastException

State.local("key", "fourty-two"); // overwrite the value with a different type</code></pre>
			<p class="tip">Be careful when storing or modifying states because multiple modifications may happen at the same time.<br />
			Have a look at <a href="#howto-atomic">Atomic Operations</a> for more info.</p>
			</article>
			
			<article>
			<h2 id="howto-chain">Chain Endpoints</h2>
			<p>In certain cases, it's useful to call (or relay to) another API endpoint without performing a full HTTP roundtrip. 
			Instead of making an external HTTP request, Uniqorn allows you to internally chain endpoints using the <code>Api.chain()</code> method.</p>
			<p>Why use endpoint chaining?</p>
			<ul>
				<li><strong>Avoid extra network overhead</strong>: Calls remain within the application.</li>
				<li><strong>Reuse existing logic</strong>: No need to duplicate endpoint functionality.</li>
				<li><strong>Improve modularity</strong>: Split logic into smaller, maintainable endpoints.</li>
				<li><strong>Group atomic operations</strong>: Combine multiple calls into one request.</li>
			</ul>
			<p class="warning">Caution, if you chain endpoints, it becomes difficult to implement a rollback mechanism. Always check if there are side effects
			or consequences when one of the chained calls fails.</p>
			<p>The <code>Api.chain()</code> method allows you to call an internal API endpoint as if it were a function. The result is returned as a Data object.</p>
			<pre><code class="language-java">new Api("/api/relay", "GET")
	.process(data -> {
		return Api.chain("/api/target");
	});</code></pre>
			<p>If you need to specify input parameters or change the authenticated user, use one of the overloads to fine-tune the target API call.<br />
			Example using chaining for aggregation of data:</p>
			<pre><code class="language-java">new Api("/api/user-profile", "GET")
	.parameter("userId")
	.process(data -> {
		Data user = Api.chain("/api/user", "GET", data);
		Data settings = Api.chain("/api/settings", "GET", data);

		return JSON.object()
			.put("user", user)
			.put("settings", settings);
	});</code></pre>
			<p class="tip">The target endpoint does not know if it is chained or called normally, be sure to use <code>try...catch</code> to handle exceptions.</p>
			</article>
			
			<article>
			<h2 id="howto-atomic">Atomic Operations</h2>
			<p>When working with shared data, concurrency can lead to race conditions, causing inconsistent or lost updates. One way to solve this problem is
			to use <code>.concurrency(1)</code> but this applies to the entire API. To ensure atomicity on selected operations, Uniqorn provides 
			an easy-to-use method:</p>
			<pre><code class="language-java">Api.atomic(() -> { /* Your code here */ });</code></pre>
			<p>This ensures that only one atomic block runs at a time, preventing conflicts in shared data or operations.</p>
			<h3>When to Use Atomic Execution?</h3>
			<p>Without atomic execution, multiple concurrent requests could modify shared data incorrectly. Consider this <em>non-atomic</em> counter update:</p>
			<pre><code class="language-java">new Api("/api/increment", "POST")
	.process(data -> {
		int count = Api.global("counter");
		// &lt;-- concurrency issue here
		Api.global("counter", count + 1);
		return JSON.object().put("counter", count);
	});</code></pre>
			<p>If two requests execute at the same time, both might read the same initial value, leading to lost updates. In this case you could use an 
			<code>AtomicInteger</code> but it may not be so easy in all cases.</p>
			<p>To make sure operations execute sequentially, wrap them in <code>Api.atomic()</code>:</p>
			<pre><code class="language-java">new Api("/api/increment", "POST")
	.process(data -> {
		...
		int counter = Api.atomic(() -> {
			int count = Api.global("counter");
			Api.global("counter", count + 1);
			return count;
		});
		
		return JSON.object().put("counter", counter);
	});</code></pre>
			<p class="tip">Note that the <code>Api.atomic()</code> method may return a value, or not depending on your needs.</p>
			<h3>When <em>Not</em> to Use Atomic Execution?</h3>
			<p>Atomic operations have an overhead cost in terms of processing power and lock out all other API from your instance so you can
			safely use <a href="#howto-sharing">States &amp; Sharing Data</a>. This is a strong bottleneck if not managed carefully.</p>
			<p>If you are reading a value without modifying it, or if you are performing independent operations, then you should avoid using
			the atomic operations.</p>
			</article>
			
			<article>
			<h2 id="howto-background">Background Operations</h2>
			<p>When building an API, there are situations where a request triggers an operation that doesn't need to complete before returning a response. 
			For example, logging user activity, sending an email, or processing a large dataset might take a few seconds, but the client doesn't need to 
			wait for these tasks to finish.</p>
			<p>To handle these cases, Uniqorn provides a simple way to defer tasks using <code>Api.defer()</code>. 
			This allows you to run background operations without blocking the API response, ensuring a smoother user experience and preventing unnecessary delays.</p>
			<h3>Using Background Tasks</h3>
			<p>The <code>Api.defer()</code> method accepts a block of code that should be executed asynchronously.
			Unlike a normal method call, which runs immediately and returns a result, a deferred task is <em>scheduled for execution in the background</em>, 
			and the main API code proceeds without waiting for the completion of the background task.</p>
			<p>This approach is useful when you need to:</p>
			<ul>
				<li>Perform a non-urgent operation (e.g., logging, analytics, sending notifications).</li>
				<li>Improve response time by offloading heavy tasks.</li>
				<li>Avoid request timeouts caused by long-running operations.</li>
			</ul>
			<p>For example, this simple API endpoint sends a notification to users. Instead of making the client wait until the email is sent, 
			we defer the operation:</p>
			<pre><code class="language-java">new Api("/api/notify", "POST")
	.parameter("email", Input.isEmail)
	.parameter("text", Input.isNotEmpty)
	.process(data -> {
		// send the email in the background
		Api.defer(() -> {
			sendEmail(data.get("email"), data.get("text"));
		});
		
		// the response is sent immediately
		return JSON.object().put("success", true);
	});</code></pre>
			<p>With this approach, the API immediately completes while the actual email is sent asynchronously. The client never experiences a delay, 
			even if sending the email takes a few seconds.</p>
			<h3>Passing Data to Deferred Tasks</h3>
			<p>Because deferred tasks run <em>outside of the API request's execution scope</em>, you cannot rely on <code>State.local()</code>. 
			The local state is tied to the request lifecycle, and once the request ends, it is no longer accessible.</p>
			<p>For example, this would <strong>not work</strong> as expected:</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		Api.defer(() -> {
			String userId = State.local("userId"); // this will not work
			doSomething(userId);
		});
		
		return null;
	});</code></pre>
			<p>Instead, always pass necessary data explicitly when deferring tasks:</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		String userId = State.local("userId");
		
		Api.defer(() -> {
			doSomething(userId); // works correctly
		});
		
		return null;
	});</code></pre>
			<h3>Handling Errors</h3>
			<p>Since deferred operations run independently of the API request, any errors they produce will not be sent back to the client.</p>
			<p class="tip">If an exception occurs inside a background task and isn't handled, it will <em>fail silently</em>.</p>
			<p>If you need to handle failures, be sure to wrap deferred operations in a try-catch block:</p>
			<pre><code class="language-java">Api.defer(() -> {
	try {
		doSomething();
	} catch(Exception e) {
		handleError();
	}
});</code></pre>
			<h3>When <em>Not</em> to Use Background Tasks</h3>
			<p>While deferring operations can significantly improve API responsiveness, there are situations where using a background task may 
			be inappropriate or even counterproductive.</p>
			<ul>
				<li>When you need the task to complete before responding:
				<pre><code class="language-java">new Api("/api/checkout", "POST")
	.process(data -> {
		Api.defer(() -> processPayment(data)); // Dangerous: no confirmation
		
		return "Payment request received.";
	});</code></pre>
				</li>
				<li>When you need immediate feedback on success or failure, such as operations that will perform a validation against input data,
				checking credentials or other verifications:
				<pre><code class="language-java">new Api("/api/signup", "POST")
	.parameter("email")
	.process(data -> {
		Api.defer(() -> {
			String email = data.asString("email");
			if (checkIfValid(email)) // Dangerous: check email before
				sendEmail(email);
		});
		
		return "Signup email sent.";
	});</code></pre>
				</li>
				<li>When you expect strict execution order, since background tasks are asynchronous, you have no guarantee about their execution order:
				<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		Api.defer(() -> stepOne());  
		Api.defer(() -> stepTwo()); // Might execute before stepOne()
		
		return "Steps scheduled.";
	});</code></pre>
				</li>
				<li>When the deferred task is computationally expensive and may stack up on the server:
				<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		Api.defer(() -> veryLongIntensiveTask());
		
		return "Process started.";
	});</code></pre>
				</li>
			</ul>
			<p>Deferring operations is a powerful technique, but it is <em>not a shortcut to infinite scalability</em>. While background tasks create the 
			impression of an immediate response, they still run on the same server and contribute to its overall workload. If heavily used, background 
			processing will affect other API requests, lead to resource starvation, or introduce uncontrolled growth if tasks pile up faster than they 
			are processed.</p>
			<p>Scheduling a task in the background is inherently heavier than running it directly, so you should consider acceptable response time 
			and balance it with the need for a background task.</p>
			<pre><code class="language-java">new Api("/api/test", "GET")
	.process(data -> {
		Api.defer(() -> veryQuickTask()); // Overkill for a quick operation
		
		return "Process started.";
	});</code></pre>
			</article>
		</section>
	
	</main>
	<script type="text/javascript">
		document.querySelectorAll("pre code").forEach(e => Prism.highlightElement(e));
	</script>
</body>
</html>